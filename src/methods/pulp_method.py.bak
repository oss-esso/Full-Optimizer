"""
PuLP-based optimizer implementation.
"""
from typing import Dict, List, Optional, Any, Tuple
import pulp
import time
import logging

# Import from parent directory
from ..data_models import OptimizationResult, OptimizationObjective

def optimize_with_pulp(self):
        """
        Solves the optimization problem using PuLP directly as a simpler approach
        compared to Benders decomposition.
        """
        import pulp

        # Create the optimization model
        model = pulp.LpProblem("Food_Production_Optimization", pulp.LpMaximize)
        
        # Decision variables
        # x_ij: hectares of food j grown on farm i
        x = {}
        # y_ij: binary variable indicating if food j is grown on farm i
        y = {}
        
        # Initialize variables
        for farm in self.farms:
            for food in self.foods:
                x[farm, food] = pulp.LpVariable(f"x_{farm}_{food}", lowBound=0)
                y[farm, food] = pulp.LpVariable(f"y_{farm}_{food}", cat='Binary')
        
        # Get weight parameters - be flexible with naming
        weights = {}
        if 'objective_weights' in self.parameters:
            weights = self.parameters['objective_weights']
        elif 'weights' in self.parameters:
            weights = self.parameters['weights']
        else:
            # Default equal weights
            weights = {
                'nutritional_value': 0.2,
                'nutrient_density': 0.2,
                'environmental_impact': 0.2,
                'affordability': 0.2,
                'sustainability': 0.2
            }
            self.logger.warning("No weights found in parameters, using default equal weights.")
        
        # Objective function: maximize weighted sum of food scores
        objective = pulp.lpSum([
            (
                weights['nutritional_value'] * self.foods[food].get('nutritional_value', 0) +
                weights['nutrient_density'] * self.foods[food].get('nutrient_density', 0) +
                weights['affordability'] * self.foods[food].get('affordability', 0) +
                weights['sustainability'] * self.foods[food].get('sustainability', 0) -
                weights['environmental_impact'] * self.foods[food].get('environmental_impact', 0)
            ) * x[farm, food]
            for farm in self.farms
            for food in self.foods
        ])
        
        model += objective
        
        # Constraints
        
        # 1. Land availability constraints
        for farm in self.farms:
            model += pulp.lpSum([x[farm, food] for food in self.foods]) <= self.parameters['land_availability'][farm], f"Land_Constraint_{farm}"
        
        # 2. Food group constraints - at least one food from each group across all farms
        if self.food_groups:  # Only add if food groups exist
            for group, foods in self.food_groups.items():
                if foods:  # Only add if the group has foods
                    min_foods = 1  # Require at least 1 food from each group
                    model += pulp.lpSum([y[farm, food] for farm in self.farms for food in foods]) >= min_foods, f"Min_Foods_{group}"
        
        # 3. Linking constraints - x and y
        for farm in self.farms:
            for food in self.foods:
                land_availability = self.parameters['land_availability'][farm]
                max_percentage = self.parameters.get('max_percentage_per_crop', {}).get(food, 0.3)  # Default to 30%
                
                # If y=0, then x=0 
                # If y=1, then x <= max_percentage * land_availability
                model += x[farm, food] <= land_availability * max_percentage * y[farm, food], f"Upper_Link_{farm}_{food}"
                
                # Minimum planting area if selected - use a small value if not specified
                min_area = max(self.parameters.get('min_planting_area', {}).get(food, 0), 0.0001)  # Ensure positive value
                model += x[farm, food] >= min_area * y[farm, food], f"Lower_Link_{farm}_{food}"
        
        # 4. Farm utilization - reduce to 20% minimum utilization for feasibility
        for farm in self.farms:
            min_util = 0.2  # Use 20% instead of 75%
            model += pulp.lpSum([x[farm, food] for food in self.foods]) >= min_util * self.parameters['land_availability'][farm], f"Min_Land_Use_{farm}"
        
        # 5. Food variety constraints - simplified to improve feasibility
        for farm in self.farms:
            # At least one food per farm
            model += pulp.lpSum([y[farm, food] for food in self.foods]) >= 1, f"Min_Foods_{farm}"
            
            # Relaxed max foods constraint - at most 8 to keep it manageable
            model += pulp.lpSum([y[farm, food] for food in self.foods]) <= 8, f"Max_Foods_{farm}"
        
        # 6. Add constraint for minimum total land utilization - reduced from 70% to 50%
        total_land = sum(self.parameters['land_availability'][farm] for farm in self.farms)
        min_total_usage = 0.5 * total_land  # Reduced from 70% to 50%
        model += pulp.lpSum([x[farm, food] for farm in self.farms for food in self.foods]) >= min_total_usage, "Min_Total_Land"
            
        # Solve the model with increased time limit and relaxed gap
        solver = pulp.PULP_CBC_CMD(msg=True, timeLimit=120, options=['allowableGap=0.05'])
        model.solve(solver)
        
        # Check status
        self.logger.info(f"Optimization status: {pulp.LpStatus[model.status]}")
        obj_value = pulp.value(model.objective)
        self.logger.info(f"Objective value: {obj_value}")
        
        # Extract solution even if reported as infeasible but with a valid objective value
        solution = {}
        if model.status == pulp.LpStatusOptimal or (obj_value is not None and obj_value > 0):
            self.logger.info("Extracting solution from PuLP model...")
            for farm in self.farms:
                farm_total = 0
                for food in self.foods:
                    # Check if the variable has a value and it's significant
                    x_val = x[farm, food].value()
                    y_val = y[farm, food].value()
                    
                    if x_val is not None and x_val > 0.01:  # Include if non-negligible area
                        solution[(farm, food)] = x_val
                        farm_total += x_val
                        self.logger.info(f"  Farm {farm}, Food {food}: {x_val:.2f} hectares (y={y_val})")
                
                # Log total land allocated for this farm
                self.logger.info(f"  Total land allocated for {farm}: {farm_total:.2f} hectares")
        else:
            # If truly infeasible, log constraint status to identify problematic constraints
            self.logger.warning("PuLP model reported as infeasible, checking constraints...")
            
            # Check land availability constraints
            for farm in self.farms:
                total_allocated = sum(x[farm, food].value() or 0 for food in self.foods)
                available = self.parameters['land_availability'][farm]
                self.logger.info(f"  {farm} land: Allocated={total_allocated:.2f}, Available={available:.2f}")
            
            # Check minimum utilization constraints
            for farm in self.farms:
                total_allocated = sum(x[farm, food].value() or 0 for food in self.foods)
                min_required = 0.2 * self.parameters['land_availability'][farm]
                self.logger.info(f"  {farm} min utilization: Allocated={total_allocated:.2f}, Required={min_required:.2f}")
            
            # Check food selection constraints
            for farm in self.farms:
                foods_selected = sum(1 for food in self.foods if y[farm, food].value() > 0.5)
                self.logger.info(f"  {farm} foods selected: {foods_selected}")
        
        # Calculate metrics
        metrics = self.calculate_metrics(solution)
        self.logger.info("Calculated metrics:")
        for metric, value in metrics.items():
            self.logger.info(f"  {metric}: {value:.4f}")
        
        # Create a proper result object - use non-zero objective if available
        result = OptimizationResult(
            status="optimal" if solution else "infeasible",  # Override status if we have a solution
            objective_value=obj_value if obj_value is not None and obj_value > 0 else 0.0,
            solution=solution,
            metrics=metrics,
            runtime=0.0  # Will be updated in main
        )
        
        return result